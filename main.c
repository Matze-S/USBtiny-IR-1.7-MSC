// ======================================================================
// IR receiver and LCD controller with USB interface.
//
// Read IR mark/space patterns from a TSOP1738 on the ICP input pin.
// Mark and space periods are measured in units of 12Mhz/1024, which is
// 85.33 us. Up to 36 periods are stored in a buffer, where they can
// be read via a USB request. The buffer layout and USB requests are
// compatible with the "IgorPlug-USB" device, which is supported by LIRC
// through the "igorplugusb" driver. This implementation should also
// work with that driver. If IgorPlug-USB compatibility is not required,
// the resolution could be improved by reducing SCALING to 9, and you
// could also get rid of the additional endpoint (USBTINY_ENDPOINT).
//
// There are some IR protocols with very long packets length, such as
// the "NEC" protocol (http://www.sbprojects.com/knowledge/ir/nec.htm).
// This protocol uses 67 mark/space periods, which is too much for the
// limited amount of RAM in the ATtiny2313. Simply truncating the
// packet to the amount of available buffer space is not an option,
// because the significant bits are at the end of the packet. Instead,
// a buffer of 36 bytes (IR_MAX) is used, of which the last 16 bytes
// (IR_WRAP) are used as a circular buffer. Because both the address
// (16 periods) and the command code (16 periods) are sent twice (normal
// and inverted), the wrapping will result in a buffer with both the
// device address and the inverted command code. Other IR protocols are
// typically shorter than 36 periods.
//
// 16-bit Timer1 is initialized in normal mode with a clock of 12MHz/8.
// Both the positive and negative edges of the IR input signal on the
// ICP input pin trigger an input capture interrupt, because the edge
// selection is toggled on every interrupt. Output compare register A
// is used for a timeout to detect the end of an IR transmission.
// The timeout value is updated on every edge. When at least 4 edges
// were detected when a timeout occurs, the packet count ir.count is
// incremented and the ir.length byte is set to the packed length. This
// byte is checked when a read request is received via USB to see if a
// packet is available
//
// The two interrupt handlers in this file run for more than 28 cycles,
// so they need to reenable interrupts to allow USB interrupts to be
// handled in time. To avoid nested IR interrupts, the input capture and
// output compare interrupts are disabled before the global interrupt
// flag is set. In the input capture interrupt handler, the interrupts
// are disabled for a maximum of 27, 27 and 27 cycles, and in the output
// compare interrupt handler for 21, 23 and 22 cycles. Unfortunately,
// it was not possible to meet the 28 cycle maximum for the input
// capture interrupt handler without using some inline assembly.
// Because the limits are so tight, the code is fragile, and may break
// for a new gcc version.
//
// The IR receiver is disabled during an IR buffer read, so that a
// packet that is being tranmitted to the host, is not overwritten by
// the next packet. When a transfer is in progress, 'inpos' has a value
// other than 0xff. When the buffer is read completely, the IR receiver
// is reenabled again, but when the next IR packet has already started,
// this packed is discarded by setting 'edges' to 0xff.
//
// There are two USB request codes to control the LCD, one to write
// instructions, and one to write data to the display. OUT transfers
// are used to transfer up to 255 bytes for a single request.
//
// Stack space calculations for gcc-4.1.0 and gcc-4.3.4:
//
//   0  main (stack reset)
//   0      lcd_init (inlined)
//   0      ir_init (inlined)
//   2      usb_init
//   5      usb_poll
//   0          usb_receive (inlined)
//   2              usb_setup
//   5              usb_out
//   3                  lcd_write
//   0                      lcd_read4 (inlined)
//   2                      lcd_write4
//   0          usb_transmit (inlined)
//   4              usb_int
//   2              crc
//
// Maximum stack space is 5+5+3+2=15.
// Total stack usage:
// - USB interrupt:			11 bytes
// - IR input capture interrupt:	12 bytes
// - IR output compare interrupt: 	 7 bytes
// - main():				15 bytes
// The two IR interrupt handler cannot be active simultaneously, so the
// maximum stack space is 15+12+11=38 bytes.
//
// NOTE: The above cycle and stack size figures were obtained by
//       inspecting the code generated by gcc-4.1.0 and gcc-4.3.4.
//       Other compiler versions may generate different code, leading
//       to different figures.
//
// Copyright 2006-2010 Dick Streefland
//
// This is free software, licensed under the terms of the GNU General
// Public License as published by the Free Software Foundation.
// ======================================================================

#include <avr/io.h>
#include <avr/interrupt.h>
#include <avr/eeprom.h>
#include <string.h>
#include "def.h"
#include "usb.h"

// ----------------------------------------------------------------------
// IR receiver definitions
// ----------------------------------------------------------------------

#define	TIMEOUT		10500	// IR transmission timeout in us
#define	IR_MAX		36	// maximum number of IR data bytes
#define	IR_WRAP		16	// wrap area at end (for 67 byte NEC protocol)
#define	SCALING		10	// 9: 42.67 us period, 10: 85.33 us period
#define	LED		(D,5)	// I/O port for LED

#define MSC_EXT 1

#if MSC_EXT
#undef LED
#define YELLOW_LED  (D,0)
#define GREEN_LED   (D,1)
#define BLUE_LED    (D,3)
#define RED_LED     (D,5)
#define ALL_LED_MASK   (_BV(0)|_BV(1)|_BV(3)|_BV(5))
#define INFO_LED_MASK  (_BV(0)|_BV(1)|_BV(3))

#ifdef __AVR_ATtiny4313__
#define	LCD_PRESENT	1
#else /* __AVR_ATtiny4313__ */
#define	LCD_PRESENT	0
#endif /* __AVR_ATtiny4313__ */

#include <util/delay.h>
#endif /* MSC_EXT */

enum
{
	// Generic requests
	USBTINY_ECHO,		// echo test

	// IgorPlug-USB requests
	IGORPLUG_CLEAR,		// clear IR data
	IGORPLUG_READ,		// read IR data (wValue: offset)

#if MSC_EXT
  IGORPLUG_SETDATAPORTDIRECTION=3,
  IGORPLUG_GETDATAPORTDIRECTION=4,
	IGORPLUG_SETOUTDATAPORT=5,
  IGORPLUG_GETOUTDATAPORT=6,
  IGORPLUG_GETINDATAPORT=7,
  IGORPLUG_EEPROMREAD=8,
  IGORPLUG_EEPROMWRITE=9,
  IGORPLUG_RS232SEND=10,
  IGORPLUG_RS232READ=11,
  IGORPLUG_SETRS232BAUD=12,
  IGORPLUG_VETRS232BAUD=13,
#endif /* MSC_EXT */

#if	LCD_PRESENT
	// LCD requests
	LCD_INSTR = 20,		// write instructions to LCD (via OUT)
	LCD_DATA,		// write data to LCD (via OUT)
#endif /* LCD_PRESENT */
};

static	byte_t	inpos;		// read position for usb_in(), or 0xff
static	byte_t	edges;		// incremented for each edge
static	struct			// IgorPlug-USB compatible data layout
{
	byte_t	length;		// length of data[]
	byte_t	count;		// incremented for each IR packet
	byte_t	offset;		// not used
	byte_t	data[IR_MAX];	// mark/space periods}		ir;

byte_t ir_onoff_code [] EEMEM = {

      31,  29,   6,  15,   6,  15,   6,   8,   6,  15,   6,   8,   6,  15,   6,   8,
       6,   8,   6,   8,   6,  15,   6,   8,   6,   8,   6,   8,   6,   8,   6,  15,
//    0x1F,0x1D,0x06,0x0F,0x06,0x08,0x06,0x0F,0x06,0x08,0x06,0x08,0x06,0x08,0x06,0x0F,
//    0x06,0x08,0x06,0x08,0x06,0x0F,0x06,0x08,0x06,0x08,0x06,0x08,0x06,0x08,0x06,0x0F
};
      
// ----------------------------------------------------------------------
// LCD definitions
// ----------------------------------------------------------------------

//#define	LCD_PRESENT	1 // set to 0 to remove LCD support

#define	DDR		DDRB
#define	PORT	PORTB
#define	PIN		PINB

#define	D4		0
#define	RS		4
#define	RW		5
#define	E		  6

#define	MASK_D4		(0xf << D4)
#define	MASK_RS		(1 << RS)
#define	MASK_RW		(1 << RW)
#define	MASK_E		(1 << E)

#if MSC_EXT
#define LIGHT 7
#define MASK_LIGHT (1 << LIGHT)
#endif /* MSC_EXT */

#ifndef	ICIE1
#define	ICIE1		TICIE1
#endif

// ----------------------------------------------------------------------
// Handler for timer1 input capture interrupt: edge on IR input
// ----------------------------------------------------------------------
ISR(TIMER1_CAPT_vect)
{
	static	uint_t	prev;
	uint_t		stamp;
	byte_t		delta;
	byte_t		e;

	TIMSK = 0;				// disable both IR interrupts
	sei();					// allow USB interrupt
	TCCR1B ^= _BV(ICES1);			// toggle edge detector
	stamp = ICR1;				// get time stamp
	asm volatile(
		"push	%A0\n"			// save stamp
		"push	%B0\n"
		:
		: "w"(stamp), "w"(prev)		// "w"(prev) reduces register usage
	);
	stamp -= prev;				// calculate delta in-place
	stamp += 1 << (SCALING - 3 - 1);	// round
	stamp >>= (SCALING - 3);		// scale
	asm volatile(
		"mov	%0,%A1\n"		// delta = stamp & 0xff
		"pop	%B1\n"
		"pop	%A1\n"			// restore stamp
		: "=r"(delta)
		: "w"(stamp)
	);
	prev  = stamp;
	OCR1A = stamp + 12L * TIMEOUT / 8;	// update timeout value
	cli();					// enter critical region
	e = edges;
	if	( e != 0xff )			// packet should not be ignored?
	{
		if	( e > IR_MAX )		// packet too long for buffer?
		{
			//e -= IR_WRAP;		// wrap, don't truncate
//      memcpy(&ir.data[10], &ir.data[10+8], IR_MAX-10-8);
//      e -= 8;
      for (e = 10; e < IR_MAX-8; ++e) ir.data[e] = ir.data[e+8];
      e = edges-8;
		}

		if	( inpos == 0xff )	// update ir only when USB idle
		{
			ir.length = 0;		// discard previous packet
			if	( e > 0 )
			{
				ir.data[e - 1] = delta;
			}
		}
		edges = e + 1;
	}
	sei();					// allow USB interrupt
	SET(YELLOW_LED);// switch LED on
	e = _BV(OCIE1A) | _BV(ICIE1);
	asm volatile("" :: "r"(e));		// force evaluation of "e"
	cli();
	TIMSK = e;				// reenable IR interrupts
}

// ----------------------------------------------------------------------
// Handler for timer1 output compare A interrupt: IR transmission timeout
// ----------------------------------------------------------------------
ISR(TIMER1_COMPA_vect)
{
	TIMSK = 0;				// disable both IR interrupts
	sei();					// allow USB interrupt
	CLR(YELLOW_LED);// switch LED off
	cli();					// enter critical region
	if	(  edges >= 4			// at least two pulses (NEC)
		&& edges != 0xff		// packet should not be ignored
		&& inpos == 0xff		// update ir only when USB idle
		)
	{
		ir.count++;
		ir.length = edges - 1;		// new packet is complete
	}
	edges = 0;
	sei();					// allow USB interrupt
	TCCR1B &= ~_BV(ICES1);			// reset to negative edge
	cli();
	TIMSK = _BV(OCIE1A) | _BV(ICIE1);	// reenable IR interrupts
}

// ----------------------------------------------------------------------
// Initialize the IR receiver.
// ----------------------------------------------------------------------
static	void	ir_init ( void )
{
	OUTPUT(YELLOW_LED);
	TCCR1B = _BV(ICNC1)	// noise canceler, trigger on negative edge
	       | _BV(CS11);	// clock source clk/8
	TIMSK  = _BV(OCIE1A)	// output compare 1A match interrupt enable
	       | _BV(ICIE1);	// input capture 1 interrupt enable
}

#if	LCD_PRESENT
// ----------------------------------------------------------------------
// Delay <count> times 100 microseconds.
// ----------------------------------------------------------------------
__attribute__((noinline))
static	void	lcd_delay100u ( byte_t count )
{
	asm volatile(
		"0:	ldi	r25, 240\n"
		"1:	rjmp	2f\n"
		"2:	dec	r25\n"
		"	brne	1b\n"	// 240 * 5 cycles = 100us
		"	dec	r24\n"
		"	brne	0b\n"
	);
}

// ----------------------------------------------------------------------
// Write 4 bits to the LCD.
// ----------------------------------------------------------------------
__attribute__((noinline))
static	void	lcd_write4 ( byte_t data )
{
	PORT = (PORT & ~ MASK_D4) | (data << D4);
	PORT |= MASK_E;			// E high period: > 230ns
	DDR  = MASK_RS | MASK_RW | MASK_E | MASK_D4; // Dx setup time: > 80ns
	PORT &= ~ MASK_E;		// hold time: > 10ns
	DDR  = MASK_RS | MASK_RW | MASK_E;
}

// ----------------------------------------------------------------------
// Read 4 bits from the LCD.
// ----------------------------------------------------------------------
__attribute__((always_inline))
static	inline	byte_t	lcd_read4 ( void )
{
	byte_t	save;
	byte_t	data;

	save = PORT;
	PORT = MASK_RW;			// address setup time: > 40ns
	PORT |= MASK_E;			// E high period: > 230ns
	asm volatile("rjmp 0f\n0:");
	data = (PIN & MASK_D4) >> D4;	// data access time: > 160ns
	PORT = save;
	return data;
}

// ----------------------------------------------------------------------
// Write a byte to the LCD.
// ----------------------------------------------------------------------
static	void	lcd_write ( byte_t b )
{
	byte_t	h;

	do
	{
		h = lcd_read4();
		(void) lcd_read4();
	} while	( h & 0x08 );
	lcd_write4( b >> 4 );
	lcd_write4( b & 15 );
}

// ----------------------------------------------------------------------
// Initialize the LCD.
// ----------------------------------------------------------------------
static	void	lcd_init ( void )
{
	DDR = MASK_RS | MASK_RW | MASK_E;
	PORT = 0;

	//lcd_delay100u( 150 );	-- skipped because of RESET delay
	lcd_write4( 3 );
	lcd_delay100u( 41 );
	lcd_write4( 3 );
	lcd_delay100u( 1 );
	lcd_write( 0x32 );	// switch to 4-bit mode
	lcd_write( 0x28 );	// function set: 4-bit mode, two lines

#if MSC_EXT
  /* detect missing LCD after first nibble with DB7 (busyflag) written HIGH (0x8) */
  byte_t h;
  byte_t i;

  SET(YELLOW_LED);
  CLR(GREEN_LED);
  for (i = 10; i; --i) {
    TOGGLE(YELLOW_LED);
    TOGGLE(GREEN_LED);
    h = lcd_read4();
    (void)lcd_read4();
    if ((h & 0x08) == 0) {
      break;
    }
    _delay_ms(50);
  }
  CLR(YELLOW_LED);
  CLR(GREEN_LED);
  if (i == 0) {
    /* no LCD */
    PORT = 0;
	  DDR &= ~(MASK_RS | MASK_RW | MASK_E);
    return;
  }

  /* switch again to 4-bit mode with 2 lines */
	lcd_write( 0x28 );	// function set: 4-bit mode, two lines
#endif /* MSC_EXT */

	lcd_write( 0x01 );	// clear display
	lcd_write( 0x06 );	// entry mode: increment, no shift
	lcd_write( 0x0c );	// display control: on, no cursor
}
#endif	/* LCD_PRESENT */

// ----------------------------------------------------------------------
// Handle a non-standard SETUP packet.
// ----------------------------------------------------------------------
extern	byte_t	usb_setup ( byte_t data[8] )
{
	byte_t	req;
	byte_t	r;

	r = 0;

	// Generic requests
	req = data[1];
	if	( req == USBTINY_ECHO )
	{
		r = 8;
	}

	// IgorPlug-USB requests
	if	( req == IGORPLUG_CLEAR )
	{
		ir.length = 0;
		inpos = 0xff;
	}

	if	( req == IGORPLUG_READ )
	{
		cli();
		if	( ir.length > 0 )
		{
			inpos = data[2];
			r = 0xff;	// call usb_in() to get the data
		}
		else
		{
			data[0] = 0;
			r = 1;
		}
		sei();
	}

#if MSC_EXT
  if (req == IGORPLUG_SETOUTDATAPORT) {
    if (data[3]&1) SET(YELLOW_LED);
    if (data[3]&2) SET(GREEN_LED);
    if (data[3]&4) SET(BLUE_LED);
    if (data[3]&8) SET(RED_LED);
    if (data[3]&16) CLR(YELLOW_LED);
    if (data[3]&32) CLR(GREEN_LED);
    if (data[3]&64) CLR(BLUE_LED);
    if (data[3]&128) CLR(RED_LED);
  }
#endif /* MSC_EXT */

#if	LCD_PRESENT
	// LCD requests
	if	( req == LCD_INSTR )
	{
		PORT &= ~ MASK_RS;	// data will be received by usb_out()
	}
	if	( req == LCD_DATA )
	{
		PORT |= MASK_RS;	// data will be received by usb_out()
	}
#endif /* LCD_PRESENT */
	return r;
}

// ----------------------------------------------------------------------
// Handle an IN packet.
// ----------------------------------------------------------------------
extern	byte_t	usb_in ( byte_t* data, byte_t len )
{
	byte_t	n;
	byte_t	max;

	max = ir.length + 3;
	n = 0;
	while	( n < len )
	{
		if	( inpos >= max )	// end of packet?
		{
			cli();
			if	( edges )	// next packet already started?
			{
				edges = 0xff;	// ignore remainder of packet
			}
			inpos = 0xff;		// reenable receiver
			sei();
			break;
		}
		data[n++] = (& ir.length)[inpos++];
	}
	return n;
}

// ----------------------------------------------------------------------
// Handle an OUT packet.
// ----------------------------------------------------------------------
extern	void	usb_out ( byte_t* data, byte_t len )
{
#if	LCD_PRESENT
	while	( len )
	{
		lcd_write( *data++ );
		len--;
	}
#endif	/* LCD_PRESENT */
}

// ----------------------------------------------------------------------
// Main
// ----------------------------------------------------------------------
extern	int	main ( void )
{
	SPL = (RAMEND & 0xff);			// drop return address of main
	inpos = 0xff;


#if MSC_EXT
  
  DDRD |= ALL_LED_MASK;
  //OUTPUT(BLUE_LED);
  //OUTPUT(YELLOW_LED);
  //OUTPUT(GREEN_LED);
  //OUTPUT(RED_LED);
  PORTD |= INFO_LED_MASK;
  //SET(BLUE_LED);
  //SET(YELLOW_LED);
  //SET(GREEN_LED);
  //_delay_ms(250);
  //PORTD &= ~ALL_LED_MASK;
  //CLR(YELLOW_LED);
  //CLR(GREEN_LED);
  //CLR(BLUE_LED);
#endif /* MSC_EXT */

#if	LCD_PRESENT
	lcd_init();
#endif	/* LCD_PRESENT */

	ir_init();
	usb_init();

#if MSC_EXT && LCD_PRESENT
  if ((DDR & (MASK_RS | MASK_RW | MASK_E)) == (MASK_RS | MASK_RW | MASK_E)) {
    /* LCD is connected */
    const char *sMsg1 = "USBtiny-IR v1.7 ";
    const char *sMsg2 = " *** HELLO ***  ";
    PORT |= MASK_RS|MASK_LIGHT; // LCD-LED on

    DDR  |= MASK_LIGHT;
    while (*sMsg1) lcd_write(*sMsg1++);
    PORT &= ~MASK_RS;
    lcd_write(0x80|(1/* Reihe 1*/ << 6)|0 /* Spalte 0 */);
    PORT |= MASK_RS;
    while (*sMsg2) lcd_write(*sMsg2++);
    _delay_ms(250);
    _delay_ms(250);
    _delay_ms(250);
    _delay_ms(250);
    PORT &= ~MASK_LIGHT; // LCD-LED off
  } else {
    byte_t i;
    for (i = 10; i; --i) {
      TOGGLE(BLUE_LED);
      _delay_ms(50);
    }
  }
#endif	/* MSC_EXT && LCD_PRESENT */

	TCCR0B = _BV(CS00)|_BV(CS02);
  byte_t ir_onoff_delay_22ms = 10;

 	for	( ;; )
	{
    if ((TIFR & _BV(TOV0)) != 0) {
      TIFR |= _BV(TOV0);
      if (ir_onoff_delay_22ms > 0) {
        if (--ir_onoff_delay_22ms == 0) {
          /* On/Off Button wird jetzt losgelassen */
          PORTD &= ~ALL_LED_MASK;
        }
      }
    }

    extern byte_t	usb_new_address;		// new device address
    if (/* usb_new_address == 0 && */ ir.length == eeprom_read_byte(&ir_onoff_code[0])) {
      byte_t delta;
           
      for (inpos = 0; inpos < ir.length; ++inpos) {
        delta = eeprom_read_byte(&ir_onoff_code[inpos+1]) - ir.data[inpos];
        if (delta < -1 || delta > +1) break;
        //if (delta != 0) break;
      }
      if (inpos == ir.length) {
        ir_onoff_delay_22ms = 45; // ~=1000ms
        SET(GREEN_LED);
        SET(BLUE_LED);
        SET(RED_LED);
        ir.length = 0;
      }
      inpos = 0xff;		// reenable receiver
    }
		usb_poll();
	}
}
